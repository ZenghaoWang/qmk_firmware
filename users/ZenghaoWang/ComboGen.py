import argparse
from io import TextIOWrapper
from typing import List, Tuple
from dataclasses import dataclass

NEWLINE = "\n"


def write_new_line(f: TextIOWrapper, text: str, indent_lvl: int = 0):
    """
    Wrapper around the built-in file writing functionality which appends a newline to the end, with optional indenting."""
    if indent_lvl:
        f.write("\t" * indent_lvl)
    f.write(text + NEWLINE)


@dataclass
class Combo:
    # The name used in the enum.
    # Should contain both the trigger keys and the output.
    full_name: str
    # The name used for the declaration of the combo variable. Should include the trigger keys and end with combo.
    trigger_name: str
    # Whether this is a simple combo or not.
    # If yes, result will be a keycode and shift and ctrl must be NULL.
    # Otherwise, result can be anything that can be processd by SEND_STRING
    simple: bool
    result: str
    result_shift: str
    result_ctrl: str
    triggers: List[str]

    def qmk_decl(self) -> str:
        decl: str = f"const uint16_t PROGMEM {self.trigger_name}[] = " + "{"
        for kc in self.triggers:
            decl += kc + ", "
        decl += "COMBO_END};"

        return decl

    def qmk_steno_call(self) -> str:
        return f"steno_combo({self.result}, {self.result_shift}, {self.result_ctrl}, pressed, mod_state, oneshot_state);"


def parse_args() -> Tuple[str, str]:
    """
    Parse command line options to get to input and output filenames
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--input", help="Input file", required=True)
    parser.add_argument("-o", "--output", help="Output file", required=True)
    args = parser.parse_args()

    return args.input, args.output


def write_headers(f: TextIOWrapper):
    """
    Write the include statements to the file handle.
    """
    for header in [
        "// This file was automatically generated by users/ZenghaoWang/ComboGen.py.",
        '#include "quantum.h"',
        '#include "process_combo.h"',
        '#include "config.h"',
        '#include "keycodes.h"',
        '#include "tap_dance.h"',
        '#include "combos.h"',
    ]:
        write_new_line(f, header)

    f.write(NEWLINE)


def parse_combos(f: TextIOWrapper) -> List[Combo]:
    """
    Parse the entire file handle into a list of combos."""
    combos: List[Combo] = []
    for line in f.readlines():
        line = line.strip()
        # ignore comments, includes, and blank lines
        if line.startswith("//") or line.startswith("#") or not line:
            continue
        (
            full_name,
            trigger_name,
            simple,
            result,
            result_shift,
            result_ctrl,
            *triggers,
        ) = line[:-1].split(", ")
        combos.append(
            Combo(
                full_name,
                trigger_name,
                True if simple == "true" else False,
                result,
                result_shift,
                result_ctrl,
                triggers,
            )
        )
    return combos


def write_enum(f: TextIOWrapper, combos: List[Combo]):
    """
    Write the enum of all the combos to the file handle.
    """
    write_new_line(f, "enum combo_events {")
    for combo in combos:
        write_new_line(f, f"{combo.full_name},", 1)
    write_new_line(f, "COMBO_LENGTH", 1)
    write_new_line(f, "};")
    write_new_line(f, "uint16_t COMBO_LEN = COMBO_LENGTH;")
    f.write(NEWLINE)


def write_combo_decls(f: TextIOWrapper, combos: List[Combo]):
    """
    Declare each combo as a uint16_t variable.
    """
    for combo in combos:
        write_new_line(f, combo.qmk_decl())
    f.write(NEWLINE)


def write_combo_arr(f: TextIOWrapper, combos: List[Combo]):
    """
    Use each enum as an index to an array of combo actions.
    """
    write_new_line(f, "// clang-format off")
    write_new_line(f, "combo_t key_combos[] = {")

    for combo in combos:
        if combo.simple:
            line = f"[{combo.full_name}] = COMBO({combo.trigger_name}, {combo.result}),"
        else:
            line = f"[{combo.full_name}] = COMBO_ACTION({combo.trigger_name}),"
        write_new_line(f, line, 1)
    write_new_line(f, "};")
    write_new_line(f, "// clang-format on")


def write_steno_combo_func(f: TextIOWrapper, combos: List[Combo]):
    for line, indent in [
        (
            "void steno_combo(const char *lowercase, const char *uppercase, const char *ctrlcase, bool pressed, uint8_t mod_state, uint8_t oneshot_state) {",
            0,
        ),
        ("if (pressed) {", 1),
        ("clear_mods();", 2),
        ("clear_oneshot_mods();", 2),
        ("if (uppercase && (mod_state | oneshot_state) & MOD_MASK_SHIFT) {", 2),
        ("unregister_mods(MOD_MASK_SHIFT);", 3),
        ("send_string(uppercase);", 3),
        ("set_mods(mod_state);", 3),
        ("} else if (ctrlcase && (mod_state | oneshot_state) & MOD_MASK_CTRL) {", 2),
        ("unregister_mods(MOD_MASK_CTRL);", 3),
        ("send_string(ctrlcase);", 3),
        ("set_mods(mod_state);", 3),
        ("} else {", 2),
        ("send_string(lowercase);", 3),
        ("}", 2),
        ("set_mods(mod_state);", 2),
        ("}", 1),
        ("}", 0),
    ]:
        write_new_line(f, line, indent)
    f.write(NEWLINE)


def write_process_combo_event_func(f: TextIOWrapper, combos: List[Combo]):
    write_new_line(f, "void process_combo_event(uint16_t combo_index, bool pressed) {")
    write_new_line(f, "uint8_t oneshot_state = get_oneshot_mods();", 1)
    write_new_line(f, "action_tapping_process((keyrecord_t){});", 1)
    write_new_line(f, "uint8_t mod_state = get_mods();", 1)
    write_new_line(f, "switch(combo_index) {", 1)

    for combo in combos:
        if not combo.simple:
            write_new_line(f, f"case {combo.full_name}:", 2)
            write_new_line(f, combo.qmk_steno_call(), 3)
            write_new_line(f, "break;", 3)

    write_new_line(f, "}", 1)
    write_new_line(f, "};")


if __name__ == "__main__":
    input, output = parse_args()
    with open(input, "r") as input_f, open(output, "w") as output_f:
        combos: List[Combo] = parse_combos(input_f)

        write_headers(output_f)
        write_enum(output_f, combos)
        write_combo_decls(output_f, combos)
        write_combo_arr(output_f, combos)
        write_steno_combo_func(output_f, combos)
        write_process_combo_event_func(output_f, combos)
